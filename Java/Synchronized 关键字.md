`synchronized` 可以修饰 3 个地方：

1. 实例方法：加锁加到**实例对象**上
2. 静态方法：加锁加到类的**所有实例对象**上
3. 代码块：可以指定加锁到**某个对象**上

不可以修饰在构造器中，构造器本身是同步的。

`synchronized` 同步块的代码是**可重入**的。

## synchronized 的锁膨胀（锁升级）

为了优化 `synchronized ` 代码块的性能，JVM 会进行锁的膨胀（锁的状态发生了变化）：

1. **无锁**：最开始的时候，还没有执行同步代码块的时候，此时锁的状态为无锁
2. **偏向锁（Biased Locking）**：如果一个线程多次获取同一个锁，而没有其他线程竞争，则 JVM 让这个线程**偏向**该锁，省去加解锁操作（默认启用，但 JDK 15 以后被废弃）
3. **轻量级锁（Lightweight Locking）**：当有多个线程竞争时，JVM 采用 CAS（Compare-And-Swap）方式尝试获取锁，而不是直接阻塞线程
4. **重量级锁（Heavyweight Locking）**：当竞争激烈时，轻量级锁无法继续工作，就会膨胀为重量级锁，并采用 操作系统的 **Mutex（互斥锁）**，导致线程阻塞

锁的状态从 `1.` 变化（膨胀）到 `4.`。

